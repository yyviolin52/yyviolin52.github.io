{"meta":{"title":"Jacky Yuan Blog | Tech & ML","subtitle":"","description":"Digital Analytics, Web Analytics & Data Science","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"About Me","date":"2020-06-17T22:56:50.000Z","updated":"2020-06-21T02:27:43.283Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"Hi, I am Jacky Yuan. I am currently focusing on digital analytics and data science analytics track with over 5 years of domain knowledge of digital marketing. With experience working in advertising agencies and publishers, I have a deep understanding of the digital marketing ecosystem.As a comb-shaped digital marketer, I have constantly developed my knowledge and skills in programming, data analysis, web analytics, SEM, SEO, statistics and math. I always curious and dubious to data, love to explore the data and the business logic behind the projects. With experience in Kaggle competition, I have developed my basic knowledge of machine learning, and this will be continue.Real Work Experience:Database: MS SQL Server, MySQL, Amazon Athena, BigQueryStatistical Tool: Python (Numpy, Pandas, scikit-learn, SciPy, Beautiful Soup), R Studio, SAS Enterprise Guide/Studio, SQL, Excel, etc.Data Visualization: Tableau, Birst, Google Data Studio, Adobe Analysis Workspace, Python(Matplotlib, Seaborn), R(ggplot2)Web Analytics: Google Analytics 360 and Adobe Analytics. Both certified. Marketing Attribution Models and Marketing Mic Model.Paid Media (PPC) / Search Engine Marketing(SEM):Google AdWords (Search, Display, Google Shopping, Dynamic Campaign, YouTube, Display Remarketing/ Search RLSA), DoubleClick, Bing Ads, Facebook Ads, Instagram Ads, Amazon Ads, Search Engine Optimizers (Kenshoo, Marin, etc.)Search Engine Optimization (SEO): SEO Keywords Research, SEO Friendly Design and Site Audit, Duplicate content Analysis and Solutions, Content SEO Strategy and Outreach Methods, Schema Markup, Local SEO, YouTube SEO, Smart Link BuildingA/B, multivariate testing tool: Optimzely, Google Optimize"},{"title":"categories","date":"2020-06-17T22:56:49.000Z","updated":"2020-06-17T22:57:55.041Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"projects","date":"2020-06-17T22:56:48.000Z","updated":"2020-06-17T22:57:55.040Z","comments":true,"path":"projects/index.html","permalink":"http://yoursite.com/projects/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-06-17T22:56:49.000Z","updated":"2020-06-17T22:57:55.041Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Important-SQL-Questions","slug":"Important-SQL-Questions","date":"2020-06-20T20:36:41.000Z","updated":"2020-06-21T20:23:02.626Z","comments":true,"path":"2020/06/20/Important-SQL-Questions/","link":"","permalink":"http://yoursite.com/2020/06/20/Important-SQL-Questions/","excerpt":"这篇SQL习题是非死不可的力扣题，我自己作为学习记录笔记目的。请勿用于商业目的。","text":"这篇SQL习题是非死不可的力扣题，我自己作为学习记录笔记目的。请勿用于商业目的。578. Get Highest Answer Rate QuestionGet the highest answer rate question from a table survey_log with these columns: uid, action, question_id, answer_id, q_num, timestamp.uid means user id; action has these kind of values: “show”, “answer”, “skip”; answer_id is not null when action column is “answer”, while is null for “show” and “skip”; q_num is the numeral order of the question in current session.Write a sql query to identify the question which has the highest answer rate.Example:1234567891011121314151617Input:+------+-----------+--------------+------------+-----------+------------+| uid | action | question_id | answer_id | q_num | timestamp |+------+-----------+--------------+------------+-----------+------------+| 5 | show | 285 | null | 1 | 123 || 5 | answer | 285 | 124124 | 1 | 124 || 5 | show | 369 | null | 2 | 125 || 5 | skip | 369 | null | 2 | 126 |+------+-----------+--------------+------------+-----------+------------+Output:+-------------+| survey_log |+-------------+| 285 |+-------------+Explanation:question 285 has answer rate 1&#x2F;1, while question 369 has 0&#x2F;1 answer rate, so output 285.Note: The highest answer rate meaning is: answer number’s ratio in show number in the same question.12345678SELECT question_id AS survey_logFROM(SELECT question_id, SUM(IF(action='answer',1,0)) / SUM(IF(action='show',1,0)) as ratioFROM demo.survey_logGROUP BY question_id) AS subGROUP BY question_idHaving MAX(ratio);这道题我自己拿进数据库跑了一下，是为了验证一下能不能写Having MAX（），注意前面要加GROUP BY因为是aggreated query。MySQL顺序执行：开始-&gt;FROM子句-&gt;WHERE子句-&gt;GROUP BY子句-&gt;HAVING子句-&gt;ORDER BY子句-&gt;SELECT子句-&gt;LIMIT子句-&gt;最终结果123456789create table demo.survey_log (uid int,action varchar(25),question_id int,answer_id int,q_num int,timestamp int);insert into demo.survey_log values(5,&#39;show&#39;,285,null,1,123);insert into demo.survey_log values(5,&#39;answer&#39;,285,124124,1,124);insert into demo.survey_log values(5,&#39;show&#39;,369,null,2,125);insert into demo.survey_log values(5,&#39;skip&#39;,369,null,2,126);--随机加了两行试一下insert into demo.survey_log values(5,&#39;show&#39;,286,null,1,123);insert into demo.survey_log values(5,&#39;answer&#39;,286,124124,1,124);我觉得网上的答案有个问题就是，如果只取一个LIMIT 1，会造成相同的回答率的结果只有一个。我个人不推荐，见网友Query：12345678910SELECT question_id AS &#39;survey_log&#39;FROM ( SELECT question_id, SUM(CASE WHEN action&#x3D;&#39;answer&#39; THEN 1 ELSE 0 END) AS num_answer, SUM(CASE WHEN action&#x3D;&#39;show&#39; THEN 1 ELSE 0 END) AS num_show FROM survey_log GROUP BY question_id ) AS tORDER BY (num_answer &#x2F; num_show) DESCLIMIT 0,1还有一种写法12345SELECT question_id AS survey_logFROM survey_logGROUP BY question_idORDER BY SUM(IF(action&#x3D;&#39;answer&#39;, 1, 0)) &#x2F; SUM(IF(action&#x3D;&#39;show&#39;, 1, 0)) DESCLIMIT 0,1;597. Friend Requests I: Overall Acceptance RateIn social network like Facebook or Twitter, people send friend requests and accept others’ requests as well. Now given two tables as below:Table: friend_request1234567891011121314151617| sender_id | send_to_id |request_date||-----------|------------|------------|| 1 | 2 | 2016_06-01 || 1 | 3 | 2016_06-01 || 1 | 4 | 2016_06-01 || 2 | 3 | 2016_06-02 || 3 | 4 | 2016-06-09 |Table: request_accepted| requester_id | accepter_id |accept_date ||--------------|-------------|------------|| 1 | 2 | 2016_06-03 || 1 | 3 | 2016-06-08 || 2 | 3 | 2016-06-08 || 3 | 4 | 2016-06-09 || 3 | 4 | 2016-06-10 |Write a query to find the overall acceptance rate of requests rounded to 2 decimals, which is the number of acceptance divide the number of requests.For the sample data above, your query should return the following result.123|accept_rate||-----------|| 0.80|Note:The accepted requests are not necessarily from the table friend_request. In this case, you just need to simply count the total accepted requests (no matter whether they are in the original requests), and divide it by the number of requests to get the acceptance rate.It is possible that a sender sends multiple requests to the same receiver, and a request could be accepted more than once. In this case, the ‘duplicated’ requests or acceptances are only counted once.If there is no requests at all, you should return 0.00 as the accept_rate.Explanation: There are 4 unique accepted requests, and there are 5 requests in total. So the rate is 0.80.Follow-up:Can you write a query to return the accept rate but for every month?How about the cumulative accept rate for every day?1234567ROUND( IFNULL( (SELECT count(*) FROM (SELECT DISTINCT requester_id, accepter_id FROM request_accepted) AS A) / (SELECT count(*) FROM (SELECT DISTINCT sender_id, send_to_id FROM friend_request) AS B) ,0),2) AS accept_ratecount( distinct col1 , col2 , col3 , .......) from table123456&#96;&#96;&#96;但是，这样是不允许的???，因为count是不能统计多个字段的，虽然distinct是可行的。有种比较直接的方法就是把消除重复后在统计查询:&#96;&#96;&#96;select count(*) from (select distinct col1 ,col2 , col3 from table)A但是，我的MYSQL版本可以的。https://dba.stackexchange.com/questions/127564/how-to-use-count-with-multiple-columns为了回答Follow Up题目，我亲测。1234567891011create table demo.request_accepted( requester_id int, accepter_id varchar(80), accept_date MEDIUMTEXT );insert into demo.request_accepted values(&#39;1&#39;,&#39;2&#39;,&#39;2016-06-03&#39;);insert into demo.request_accepted values(&#39;1&#39;,&#39;3&#39;,&#39;2016-06-08&#39;);insert into demo.request_accepted values(&#39;2&#39;,&#39;3&#39;,&#39;2016-06-08&#39;);insert into demo.request_accepted values(&#39;3&#39;,&#39;4&#39;,&#39;2016-06-09&#39;);insert into demo.request_accepted values(&#39;3&#39;,&#39;4&#39;,&#39;2016-06-10&#39;);Follow Up1.Can you write a query to return the accept rate but for every month?123456SELECT ROUND(IFNULL((A.accept_num/B.request_num),0),2) AS accept_rate, A.accept_m AS monthFROM(SELECT COUNT(DISTINCT requester_id, accepter_id) AS accept_num, MONTH(accept_date) AS accept_m FROM demo.request_accepted GROUP BY accept_m) A,(SELECT COUNT(DISTINCT sender_id, send_to_id) AS request_num, MONTH(request_date) AS request_m FROM demo.friend_request GROUP BY request_m) BWHERE A.accept_m = B.request_mGROUP BY A.accept_m;Result{“headers”: [“accept_rate”, “month”],“values”: [[0.80, 6]]}Follow-up 2: return the cumulative accept rate for every day12345678SELECT ROUND(COUNT(DISTINCT requester_id, accepter_id) / COUNT(DISTINCT sender_id, send_to_id),2) AS accept_rate, data_table.datesFROM demo.request_accepted acp, demo.friend_request req,(SELECT request_date AS dates FROM demo.friend_requestUNIONSELECT accept_date FROM demo.request_acceptedORDER BY dates) data_tableWHERE acp.accept_date &lt;= data_table.dates AND req.request_date &lt;= data_table.datesGROUP BY data_table.dates;Result{“headers”: [“rate”, “dates”],“values”: [[0.25, “2016-06-03”], [0.75, “2016-06-08”], [0.80, “2016-06-09”], [0.80, “2016-06-10”]]}大家自己写的时候可以把demo去掉。","categories":[{"name":"Database","slug":"Database","permalink":"http://yoursite.com/categories/Database/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/tags/Leetcode/"},{"name":"Facebook","slug":"Facebook","permalink":"http://yoursite.com/tags/Facebook/"}]},{"title":"SQL-exercises-in-LeetCode-easy-part","slug":"SQL-exercises-in-LeetCode-easy-part","date":"2020-06-18T02:38:36.000Z","updated":"2020-06-19T03:38:53.171Z","comments":true,"path":"2020/06/17/SQL-exercises-in-LeetCode-easy-part/","link":"","permalink":"http://yoursite.com/2020/06/17/SQL-exercises-in-LeetCode-easy-part/","excerpt":"LeetCode中的sql练习题-easy难度部分新增本文包含LeetCode中easy难度的sql练习题的解题思路和通过代码，关于题目描述可以查看leetcode原网站，或者leetcode中文网站。此文章仅用于个人学习记录，请勿用于商业用途。This article contains the solution ideas of practice questions in LeetCode. For the description of the question, you can check the original website of leetcode. This article is only for personal learning purposes, please do not use it for commercial purposes.","text":"LeetCode中的sql练习题-easy难度部分新增本文包含LeetCode中easy难度的sql练习题的解题思路和通过代码，关于题目描述可以查看leetcode原网站，或者leetcode中文网站。此文章仅用于个人学习记录，请勿用于商业用途。This article contains the solution ideas of practice questions in LeetCode. For the description of the question, you can check the original website of leetcode. This article is only for personal learning purposes, please do not use it for commercial purposes.1241. Number of Comments per PostTable: Submissions12345678910+---------------+----------+| Column Name | Type |+---------------+----------+| sub_id | int || parent_id | int |+---------------+----------+There is no primary key for this table, it may have duplicate rows.Each row can be a post or comment on the post.parent_id is null for posts.parent_id for comments is sub_id for another post in the table.Write an SQL query to find number of comments per each post.Result table should contain post_id and its corresponding number_of_comments, and must be sorted by post_id in ascending order.Submissions may contain duplicate comments. You should count the number of unique comments per post.Submissions may contain duplicate posts. You should treat them as one post.The query result format is in the following example:123456789101112131415161718192021222324252627282930Submissions table:+---------+------------+| sub_id | parent_id |+---------+------------+| 1 | Null || 2 | Null || 1 | Null || 12 | Null || 3 | 1 || 5 | 2 || 3 | 1 || 4 | 1 || 9 | 1 || 10 | 2 || 6 | 7 |+---------+------------+Result table:+---------+--------------------+| post_id | number_of_comments |+---------+--------------------+| 1 | 3 || 2 | 2 || 12 | 0 |+---------+--------------------+The post with id 1 has three comments in the table with id 3, 4 and 9. The comment with id 3 is repeated in the table, we counted it only once.The post with id 2 has two comments in the table with id 5 and 10.The post with id 12 has no comments in the table.The comment with id 6 is a comment on a deleted post with id 7 so we ignored it.Solution:这道题的难点在于彻彻底底考察了JOIN的功底LEFT JOIN 写法1234SELECT DISTINCT A.sub_id, COUNT(DISTINCT B.sub_id) AS number_of_commentsFROM demo.sub AS A LEFT JOIN demo.sub AS B ON A.sub_id = B.parent_idWHERE A.parent_id is nullGROUP by A.sub_id;更简洁的LEFT JOIN123SELECT post_id, COUNT(DISTINCT B.sub_id) AS number_of_commentsFROM (SELECT DISTINCT sub_id AS post_id FROM demo.sub WHERE parent_id is null) AS A LEFT JOIN demo.sub AS B ON post_id = B.parent_idGROUP by post_id;RIGHT JOIN:123456789SELECT p.post_id, COUNT(DISTINCT(s.sub_id)) AS number_of_commentsFROM Submissions AS sRIGHT JOIN( SELECT DISTINCT(sub_id) as post_id FROM Submissions WHERE parent_id IS NULL)AS pON p.post_id = s.parent_idGROUP BY p.post_id1241. Number of Comments per PostTable: Submissions12345678910+---------------+----------+| Column Name | Type |+---------------+----------+| sub_id | int || parent_id | int |+---------------+----------+There is no primary key for this table, it may have duplicate rows.Each row can be a post or comment on the post.parent_id is null for posts.parent_id for comments is sub_id for another post in the table.Write an SQL query to find number of comments per each post.Result table should contain post_id and its corresponding number_of_comments, and must be sorted by post_id in ascending order.Submissions may contain duplicate comments. You should count the number of unique comments per post.Submissions may contain duplicate posts. You should treat them as one post.The query result format is in the following example:123456789101112131415161718192021222324252627282930Submissions table:+---------+------------+| sub_id | parent_id |+---------+------------+| 1 | Null || 2 | Null || 1 | Null || 12 | Null || 3 | 1 || 5 | 2 || 3 | 1 || 4 | 1 || 9 | 1 || 10 | 2 || 6 | 7 |+---------+------------+Result table:+---------+--------------------+| post_id | number_of_comments |+---------+--------------------+| 1 | 3 || 2 | 2 || 12 | 0 |+---------+--------------------+The post with id 1 has three comments in the table with id 3, 4 and 9. The comment with id 3 is repeated in the table, we counted it only once.The post with id 2 has two comments in the table with id 5 and 10.The post with id 12 has no comments in the table.The comment with id 6 is a comment on a deleted post with id 7 so we ignored it.Solution:123456SELECT P.product_id, ROUND(P.price * U.unit / SUM (U.units),2) AS average_priceFROM Prices PINNER JOIN UnitsSold UON P.product_id = U.product_idWHERE U.purchase_date BETWEEN P.start_date AND P.end_dateGROUP BY P.product_id;1280. Students and ExaminationsSQL SchemaTable: Students12345678+---------------+---------+| Column Name | Type |+---------------+---------+| student_id | int || student_name | varchar |+---------------+---------+student_id is the primary key for this table.Each row of this table contains the ID and the name of one student in the school.Table: Subjects1234567+--------------+---------+| Column Name | Type |+--------------+---------+| subject_name | varchar |+--------------+---------+subject_name is the primary key for this table.Each row of this table contains a name of one subject in the school.Table: Examinations123456789+--------------+---------+| Column Name | Type |+--------------+---------+| student_id | int || subject_name | varchar |+--------------+---------+There is no primary key for this table. It may contain duplicates.Each student from Students table takes every course from Subjects table.Each row of this table indicates that a student with ID student_id attended the exam of subject_name.Write an SQL query to find the number of times each student attended each exam.Order the result table by student_id and subject_name.The query result format is in the following example:Students table:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556+------------+--------------+| student_id | student_name |+------------+--------------+| 1 | Alice || 2 | Bob || 13 | John || 6 | Alex |+------------+--------------+Subjects table:+--------------+| subject_name |+--------------+| Math || Physics || Programming |+--------------+Examinations table:+------------+--------------+| student_id | subject_name |+------------+--------------+| 1 | Math || 1 | Physics || 1 | Programming || 2 | Programming || 1 | Physics || 1 | Math || 13 | Math || 13 | Programming || 13 | Physics || 2 | Math || 1 | Math |+------------+--------------+Result table:+------------+--------------+--------------+----------------+| student_id | student_name | subject_name | attended_exams |+------------+--------------+--------------+----------------+| 1 | Alice | Math | 3 || 1 | Alice | Physics | 2 || 1 | Alice | Programming | 1 || 2 | Bob | Math | 1 || 2 | Bob | Physics | 0 || 2 | Bob | Programming | 1 || 6 | Alex | Math | 0 || 6 | Alex | Physics | 0 || 6 | Alex | Programming | 0 || 13 | John | Math | 1 || 13 | John | Physics | 1 || 13 | John | Programming | 1 |+------------+--------------+--------------+----------------+The result table should contain all students and all subjects.Alice attended Math exam 3 times,Physics exam 2 times and Programming exam 1 time.Bob attended Math exam 1 time, Programming exam 1 time and didn&#39;t attend the Physics exam.Alex didn&#39;t attend any exam.John attended Math exam 1 time, Physics exam 1 time and Programming exam 1 time.思路: Cross Join 和inner join 没区别这里，原来三个table可以直接先写好 再写ON12345678SELECT S.student_id, S.student_name, B.subject_name, count(E.subject_name) AS attended_examsFROM Students SINNER JOIN Subjects BLEFT JOIN Examinations EON S.student_id = E.student_id AND E.subject_name = B.subject_nameGROUP BY S.student_id, S.student_name, B.subject_nameORDER BY S.student_id, S.student_name, B.subject_name;CROSS JOIN 结果一样的，过程稍微有点区别。先连结两个表：对表Students和表Subjects求笛卡尔积，得到4*3行的表，再连结三个表：对刚刚得到的新表和表Examinations进行左连结（LEFT JOIN）我看到这边几个博主省略了一列在GROUP BY里面 见CSDN网友还有 YouTube博主123456SELECT a.student_id, a.student_name, b.subject_name, COUNT(e.subject_name) AS attended_examsFROM demo.Students1 a CROSS JOIN demo.Subjects bLEFT JOIN demo.Examinations eON a.student_id = e.student_id AND b.subject_name = e.subject_nameGROUP BY a.student_id, a.student_name, b.subject_nameORDER BY a.student_id, a.student_name, b.subject_name;1294. Weather Type in Each CountrySQL SchemaTable: Countries12345678+---------------+---------+| Column Name | Type |+---------------+---------+| country_id | int || country_name | varchar |+---------------+---------+country_id is the primary key for this table.Each row of this table contains the ID and the name of one country.Table: Weather123456789+---------------+---------+| Column Name | Type |+---------------+---------+| country_id | int || weather_state | varchar || day | date |+---------------+---------+(country_id, day) is the primary key for this table.Each row of this table indicates the weather state in a country for one day.Write an SQL query to find the type of weather in each country for November 2019.The type of weather is Cold if the average weather_state is less than or equal 15, Hot if the average weather_state is greater than or equal 25 and Warm otherwise.Return result table in any order.The query result format is in the following example:Countries table:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748+------------+--------------+| country_id | country_name |+------------+--------------+| 2 | USA || 3 | Australia || 7 | Peru || 5 | China || 8 | Morocco || 9 | Spain |+------------+--------------+Weather table:+------------+---------------+------------+| country_id | weather_state | day |+------------+---------------+------------+| 2 | 15 | 2019-11-01 || 2 | 12 | 2019-10-28 || 2 | 12 | 2019-10-27 || 3 | -2 | 2019-11-10 || 3 | 0 | 2019-11-11 || 3 | 3 | 2019-11-12 || 5 | 16 | 2019-11-07 || 5 | 18 | 2019-11-09 || 5 | 21 | 2019-11-23 || 7 | 25 | 2019-11-28 || 7 | 22 | 2019-12-01 || 7 | 20 | 2019-12-02 || 8 | 25 | 2019-11-05 || 8 | 27 | 2019-11-15 || 8 | 31 | 2019-11-25 || 9 | 7 | 2019-10-23 || 9 | 3 | 2019-12-23 |+------------+---------------+------------+Result table:+--------------+--------------+| country_name | weather_type |+--------------+--------------+| USA | Cold || Austraila | Cold || Peru | Hot || China | Warm || Morocco | Hot |+--------------+--------------+Average weather_state in USA in November is (15) &#x2F; 1 &#x3D; 15 so weather type is Cold.Average weather_state in Austraila in November is (-2 + 0 + 3) &#x2F; 3 &#x3D; 0.333 so weather type is Cold.Average weather_state in Peru in November is (25) &#x2F; 1 &#x3D; 25 so weather type is Hot.Average weather_state in China in November is (16 + 18 + 21) &#x2F; 3 &#x3D; 18.333 so weather type is Warm.Average weather_state in Morocco in November is (25 + 27 + 31) &#x2F; 3 &#x3D; 27.667 so weather type is Hot.We know nothing about average weather_state in Spain in November so we don&#39;t include it in the result table.123456789SELECT country_name, CASE WHEN AVG(weather_state) &lt;= 15 THEN 'Cold' WHEN AVG(weather_state) &gt;= 25 THEN 'Hot' ELSE 'Warm' END AS weather_typeFROM Countries CLEFT JOIN Weather WON C.country_id = W.country_idWHERE W.day between '2019-11-01' and '2019-11-31'GROUP BY country_name) sub;1303. Find the Team Size 亚麻SQL SchemaTable: Employee1234567891011+---------------+---------+| Column Name | Type |+---------------+---------+| employee_id | int || team_id | int |+---------------+---------+employee_id is the primary key for this table.Each row of this table contains the ID of each employee and their respective team.Write an SQL query to find the team size of each of the employees.Return result table in any order.The query result format is in the following example:Employee Table:123456789101112131415161718192021222324+-------------+------------+| employee_id | team_id |+-------------+------------+| 1 | 8 || 2 | 8 || 3 | 8 || 4 | 7 || 5 | 9 || 6 | 9 |+-------------+------------+Result table:+-------------+------------+| employee_id | team_size |+-------------+------------+| 1 | 3 || 2 | 3 || 3 | 3 || 4 | 1 || 5 | 2 || 6 | 2 |+-------------+------------+Employees with Id 1,2,3 are part of a team with team_id &#x3D; 8.Employees with Id 4 is part of a team with team_id &#x3D; 7.Employees with Id 5,6 are part of a team with team_id &#x3D; 9.123456SELECT A.employee_id, B.team_sizeFROM Employee AS ALEFT JOIN (SELECT team_id, count(employee_id) as team_sizeFROM EmployeeGROUP BY team_id) AS BON A.team_id = B.team_id1322. Ads Performance FBSQL SchemaTable: Ads12345678910+---------------+---------+| Column Name | Type |+---------------+---------+| ad_id | int || user_id | int || action | enum |+---------------+---------+(ad_id, user_id) is the primary key for this table.Each row of this table contains the ID of an Ad, the ID of a user and the action taken by this user regarding this Ad.The action column is an ENUM type of (&#39;Clicked&#39;, &#39;Viewed&#39;, &#39;Ignored&#39;).A company is running Ads and wants to calculate the performance of each Ad.Performance of the Ad is measured using Click-Through Rate (CTR) where:CTR这里的定义是 Ad total clicks/(Ad total clicks + Ad total views)x100 具体面试和面试官确认Write an SQL query to find the ctr of each Ad.Round ctr to 2 decimal points. Order the result table by ctr in descending order and by ad_id in ascending order in case of a tie.The query result format is in the following example:Ads table:1234567891011121314151617181920212223242526272829+-------+---------+---------+| ad_id | user_id | action |+-------+---------+---------+| 1 | 1 | Clicked || 2 | 2 | Clicked || 3 | 3 | Viewed || 5 | 5 | Ignored || 1 | 7 | Ignored || 2 | 7 | Viewed || 3 | 5 | Clicked || 1 | 4 | Viewed || 2 | 11 | Viewed || 1 | 2 | Clicked |+-------+---------+---------+Result table:+-------+-------+| ad_id | ctr |+-------+-------+| 1 | 66.67 || 3 | 50.00 || 2 | 33.33 || 5 | 0.00 |+-------+-------+for ad_id &#x3D; 1, ctr &#x3D; (2&#x2F;(2+1)) * 100 &#x3D; 66.67for ad_id &#x3D; 2, ctr &#x3D; (1&#x2F;(1+2)) * 100 &#x3D; 33.33for ad_id &#x3D; 3, ctr &#x3D; (1&#x2F;(1+1)) * 100 &#x3D; 50.00for ad_id &#x3D; 5, ctr &#x3D; 0.00, Note that ad_id &#x3D; 5 has no clicks or views.Note that we don&#39;t care about Ignored Ads.Result table is ordered by the ctr. in case of a tie we order them by ad_id12345SELECT ad_id, IFNULL(ROUND(100*SUM(action='Clicked')/(SUM(action='Clicked')+SUM(action='Viewed')),2),0) AS ctrFROM AdsWHERE action in ('Clicked','Viewed')GROUP BY ad_idORDER BY ctr DESC, ad_id ASC;1327. List the Products Ordered in a Period 亚麻SQL SchemaTable: Products123456789+------------------+---------+| Column Name | Type |+------------------+---------+| product_id | int || product_name | varchar || product_category | varchar |+------------------+---------+product_id is the primary key for this table.This table contains data about the company&#39;s products.Table: Orders12345678910+---------------+---------+| Column Name | Type |+---------------+---------+| product_id | int || order_date | date || unit | int |+---------------+---------+There is no primary key for this table. It may have duplicate rows.product_id is a foreign key to Products table.unit is the number of products ordered in order_date.Write an SQL query to get the names of products with greater than or equal to 100 units ordered in February 2020 and their amount.Return result table in any order.The query result format is in the following example:Products table:1234567891011121314151617181920212223242526272829303132333435363738394041+-------------+-----------------------+------------------+| product_id | product_name | product_category |+-------------+-----------------------+------------------+| 1 | Leetcode Solutions | Book || 2 | Jewels of Stringology | Book || 3 | HP | Laptop || 4 | Lenovo | Laptop || 5 | Leetcode Kit | T-shirt |+-------------+-----------------------+------------------+Orders table:+--------------+--------------+----------+| product_id | order_date | unit |+--------------+--------------+----------+| 1 | 2020-02-05 | 60 || 1 | 2020-02-10 | 70 || 2 | 2020-01-18 | 30 || 2 | 2020-02-11 | 80 || 3 | 2020-02-17 | 2 || 3 | 2020-02-24 | 3 || 4 | 2020-03-01 | 20 || 4 | 2020-03-04 | 30 || 4 | 2020-03-04 | 60 || 5 | 2020-02-25 | 50 || 5 | 2020-02-27 | 50 || 5 | 2020-03-01 | 50 |+--------------+--------------+----------+Result table:+--------------------+---------+| product_name | unit |+--------------------+---------+| Leetcode Solutions | 130 || Leetcode Kit | 100 |+--------------------+---------+Products with product_id &#x3D; 1 is ordered in February a total of (60 + 70) &#x3D; 130.Products with product_id &#x3D; 2 is ordered in February a total of 80.Products with product_id &#x3D; 3 is ordered in February a total of (2 + 3) &#x3D; 5.Products with product_id &#x3D; 4 was not ordered in February 2020.Products with product_id &#x3D; 5 is ordered in February a total of (50 + 50) &#x3D; 100.123456SELECT A.product_name,B.unit_num AS unitFROM Products AINNER JOIN (SELECT product_id, sum(unit) as unit_numFROM OrdersWHERE order_date between '2020-02-01' and '2020-02-29'HAVING sum(unit) &gt;=100) AS B1350. Students With Invalid Departments 亚麻SQL SchemaTable: Departments12345678+---------------+---------+| Column Name | Type |+---------------+---------+| id | int || name | varchar |+---------------+---------+id is the primary key of this table.The table has information about the id of each department of a university.Table: Students123456789+---------------+---------+| Column Name | Type |+---------------+---------+| id | int || name | varchar || department_id | int |+---------------+---------+id is the primary key of this table.The table has information about the id of each student at a university and the id of the department he&#x2F;she studies at.Write an SQL query to find the id and the name of all students who are enrolled in departments that no longer exists.Return the result table in any order.The query result format is in the following example:Departments table:1234567891011121314151617181920212223242526272829303132333435+------+--------------------------+| id | name |+------+--------------------------+| 1 | Electrical Engineering || 7 | Computer Engineering || 13 | Bussiness Administration |+------+--------------------------+Students table:+------+----------+---------------+| id | name | department_id |+------+----------+---------------+| 23 | Alice | 1 || 1 | Bob | 7 || 5 | Jennifer | 13 || 2 | John | 14 || 4 | Jasmine | 77 || 3 | Steve | 74 || 6 | Luis | 1 || 8 | Jonathan | 7 || 7 | Daiana | 33 || 11 | Madelynn | 1 |+------+----------+---------------+Result table:+------+----------+| id | name |+------+----------+| 2 | John || 7 | Daiana || 4 | Jasmine || 3 | Steve |+------+----------+John, Daiana, Steve and Jasmine are enrolled in departments 14, 33, 74 and 77 respectively. department 14, 33, 74 and 77 doesn&#39;t exist in the Departments table.12345SELECT s.id, s.nameFROM Departments dLEFT JOIN Students sON d.id=s.department_idWHERE s.department_id is null;1378. Replace Employee ID With The Unique IdentifierSQL SchemaTable: Employees12345678+---------------+---------+| Column Name | Type |+---------------+---------+| id | int || name | varchar |+---------------+---------+id is the primary key for this table.Each row of this table contains the id and the name of an employee in a company.Table: EmployeeUNI12345678+---------------+---------+| Column Name | Type |+---------------+---------+| id | int || unique_id | int |+---------------+---------+(id, unique_id) is the primary key for this table.Each row of this table contains the id and the corresponding unique id of an employee in the company.Write an SQL query to show the unique ID of each user, If a user doesn’t have a unique ID replace just show null.Return the result table in any order.The query result format is in the following example:Employees table:12345678910111213141516171819202122232425262728293031323334+----+----------+| id | name |+----+----------+| 1 | Alice || 7 | Bob || 11 | Meir || 90 | Winston || 3 | Jonathan |+----+----------+EmployeeUNI table:+----+-----------+| id | unique_id |+----+-----------+| 3 | 1 || 11 | 2 || 90 | 3 |+----+-----------+EmployeeUNI table:+-----------+----------+| unique_id | name |+-----------+----------+| null | Alice || null | Bob || 2 | Meir || 3 | Winston || 1 | Jonathan |+-----------+----------+Alice and Bob don&#39;t have a unique ID, We will show null instead.The unique ID of Meir is 2.The unique ID of Winston is 3.The unique ID of Jonathan is 1.1234SELECT u.unique_id, e.nameFROM Employees eLEFT JOIN EMployeeUNI uON e.id=u.id1407. Top TravellersSQL SchemaTable: Users12345678+---------------+---------+| Column Name | Type |+---------------+---------+| id | int || name | varchar |+---------------+---------+id is the primary key for this table.name is the name of the user.Table: Rides123456789+---------------+---------+| Column Name | Type |+---------------+---------+| id | int || user_id | int || distance | int |+---------------+---------+id is the primary key for this table.city_id is the id of the city who bought the product &quot;product_name&quot;.Write an SQL query to report the distance travelled by each user.Return the result table ordered by travelled_distance in descending order, if two or more users travelled the same distance, order them by their name in ascending order.The query result format is in the following example.Users table:123456789101112131415161718192021222324252627282930313233343536373839404142+------+-----------+| id | name |+------+-----------+| 1 | Alice || 2 | Bob || 3 | Alex || 4 | Donald || 7 | Lee || 13 | Jonathan || 19 | Elvis |+------+-----------+Rides table:+------+----------+----------+| id | user_id | distance |+------+----------+----------+| 1 | 1 | 120 || 2 | 2 | 317 || 3 | 3 | 222 || 4 | 7 | 100 || 5 | 13 | 312 || 6 | 19 | 50 || 7 | 7 | 120 || 8 | 19 | 400 || 9 | 7 | 230 |+------+----------+----------+Result table:+----------+--------------------+| name | travelled_distance |+----------+--------------------+| Elvis | 450 || Lee | 450 || Bob | 317 || Jonathan | 312 || Alex | 222 || Alice | 120 || Donald | 0 |+----------+--------------------+Elvis and Lee travelled 450 miles, Elvis is the top traveller as his name is alphabetically smaller than Lee.Bob, Jonathan, Alex and Alice have only one ride and we just order them by the total distances of the ride.Donald didn&#39;t have any rides, the distance travelled by him is 0.考点是IFNULL，如果不写，Donald会是NULL123456SELECT u.name, IFNULL(sum(r.distance),0) as travelled_distanceFROM Users uLEFT JOIN Rides rON u.id = r.idGROUP BY u.nameORDER BY travelled_distance DESC, u.name;","categories":[{"name":"Database","slug":"Database","permalink":"http://yoursite.com/categories/Database/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/tags/Leetcode/"}]}],"categories":[{"name":"Database","slug":"Database","permalink":"http://yoursite.com/categories/Database/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/tags/Leetcode/"},{"name":"Facebook","slug":"Facebook","permalink":"http://yoursite.com/tags/Facebook/"}]}