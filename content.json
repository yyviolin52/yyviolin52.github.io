{"meta":{"title":"Jacky Yuan Blog | Tech & ML","subtitle":"","description":"Digital Analytics, Web Analytics & Data Science","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"About Me","date":"2020-06-17T22:56:50.000Z","updated":"2020-06-21T02:27:43.283Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"Hi, I am Jacky Yuan. I am currently focusing on digital analytics and data science analytics track with over 5 years of domain knowledge of digital marketing. With experience working in advertising agencies and publishers, I have a deep understanding of the digital marketing ecosystem.As a comb-shaped digital marketer, I have constantly developed my knowledge and skills in programming, data analysis, web analytics, SEM, SEO, statistics and math. I always curious and dubious to data, love to explore the data and the business logic behind the projects. With experience in Kaggle competition, I have developed my basic knowledge of machine learning, and this will be continue.Real Work Experience:Database: MS SQL Server, MySQL, Amazon Athena, BigQueryStatistical Tool: Python (Numpy, Pandas, scikit-learn, SciPy, Beautiful Soup), R Studio, SAS Enterprise Guide/Studio, SQL, Excel, etc.Data Visualization: Tableau, Birst, Google Data Studio, Adobe Analysis Workspace, Python(Matplotlib, Seaborn), R(ggplot2)Web Analytics: Google Analytics 360 and Adobe Analytics. Both certified. Marketing Attribution Models and Marketing Mic Model.Paid Media (PPC) / Search Engine Marketing(SEM):Google AdWords (Search, Display, Google Shopping, Dynamic Campaign, YouTube, Display Remarketing/ Search RLSA), DoubleClick, Bing Ads, Facebook Ads, Instagram Ads, Amazon Ads, Search Engine Optimizers (Kenshoo, Marin, etc.)Search Engine Optimization (SEO): SEO Keywords Research, SEO Friendly Design and Site Audit, Duplicate content Analysis and Solutions, Content SEO Strategy and Outreach Methods, Schema Markup, Local SEO, YouTube SEO, Smart Link BuildingA/B, multivariate testing tool: Optimzely, Google Optimize"},{"title":"categories","date":"2020-06-17T22:56:49.000Z","updated":"2020-06-17T22:57:55.041Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"projects","date":"2020-06-17T22:56:48.000Z","updated":"2020-06-17T22:57:55.040Z","comments":true,"path":"projects/index.html","permalink":"http://yoursite.com/projects/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-06-17T22:56:49.000Z","updated":"2020-06-17T22:57:55.041Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"SQL-execution-order","slug":"SQL-execution-order","date":"2020-06-22T12:54:59.000Z","updated":"2020-06-22T19:30:12.272Z","comments":true,"path":"2020/06/22/SQL-execution-order/","link":"","permalink":"http://yoursite.com/2020/06/22/SQL-execution-order/","excerpt":"SQL中Alias用法的疑惑以下是Stackoverflow的一个问题 https://stackoverflow.com/questions/3841295/sql-using-alias-in-group-by","text":"SQL中Alias用法的疑惑以下是Stackoverflow的一个问题 https://stackoverflow.com/questions/3841295/sql-using-alias-in-group-bysql execution orderJust curious about SQL syntax. So if I have12345678910111213SELECT itemName as ItemName, substring(itemName, 1,1) as FirstLetter, Count(itemName)FROM table1GROUP BY itemName, FirstLetterThis would be incorrect becauseGROUP BY itemName, FirstLetterreally should beGROUP BY itemName, substring(itemName, 1,1)But why can&#39;t we simply use the former for convenience?SQL is implemented as if a query was executed in the following order:FROM clauseWHERE clauseGROUP BY clauseHAVING clauseSELECT clauseORDER BY clauseFor most relational database systems, this order explains which names (columns or aliases) are valid because they must have been introduced in a previous step.So in Oracle and SQL Server, you cannot use a term in the GROUP BY clause that you define in the SELECT clause because the GROUP BY is executed before the SELECT clause.There are exceptions though: MySQL and Postgres seem to have additional smartness that allows it.总结一下：因为SELECT语句执行在后，所以除了order by时候可以用alias，其他时候不建议用了。","categories":[{"name":"Database","slug":"Database","permalink":"http://yoursite.com/categories/Database/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"}]},{"title":"Important-SQL-Questions","slug":"Important-SQL-Questions","date":"2020-06-20T20:36:41.000Z","updated":"2020-06-26T16:38:02.769Z","comments":true,"path":"2020/06/20/Important-SQL-Questions/","link":"","permalink":"http://yoursite.com/2020/06/20/Important-SQL-Questions/","excerpt":"这篇SQL习题是非死不可的力扣题，我自己作为学习记录笔记目的。请勿用于商业目的。","text":"这篇SQL习题是非死不可的力扣题，我自己作为学习记录笔记目的。请勿用于商业目的。578. Get Highest Answer Rate QuestionGet the highest answer rate question from a table survey_log with these columns: uid, action, question_id, answer_id, q_num, timestamp.uid means user id; action has these kind of values: “show”, “answer”, “skip”; answer_id is not null when action column is “answer”, while is null for “show” and “skip”; q_num is the numeral order of the question in current session.Write a sql query to identify the question which has the highest answer rate.Example:1234567891011121314151617Input:+------+-----------+--------------+------------+-----------+------------+| uid | action | question_id | answer_id | q_num | timestamp |+------+-----------+--------------+------------+-----------+------------+| 5 | show | 285 | null | 1 | 123 || 5 | answer | 285 | 124124 | 1 | 124 || 5 | show | 369 | null | 2 | 125 || 5 | skip | 369 | null | 2 | 126 |+------+-----------+--------------+------------+-----------+------------+Output:+-------------+| survey_log |+-------------+| 285 |+-------------+Explanation:question 285 has answer rate 1&#x2F;1, while question 369 has 0&#x2F;1 answer rate, so output 285.Note: The highest answer rate meaning is: answer number’s ratio in show number in the same question.12345678SELECT question_id AS survey_logFROM(SELECT question_id, SUM(IF(action='answer',1,0)) / SUM(IF(action='show',1,0)) as ratioFROM demo.survey_logGROUP BY question_id) AS subGROUP BY question_idHaving MAX(ratio);这道题我自己拿进数据库跑了一下，是为了验证一下能不能写Having MAX（），注意前面要加GROUP BY因为是aggreated query。MySQL顺序执行：开始-&gt;FROM子句-&gt;WHERE子句-&gt;GROUP BY子句-&gt;HAVING子句-&gt;ORDER BY子句-&gt;SELECT子句-&gt;LIMIT子句-&gt;最终结果123456789create table demo.survey_log (uid int,action varchar(25),question_id int,answer_id int,q_num int,timestamp int);insert into demo.survey_log values(5,&#39;show&#39;,285,null,1,123);insert into demo.survey_log values(5,&#39;answer&#39;,285,124124,1,124);insert into demo.survey_log values(5,&#39;show&#39;,369,null,2,125);insert into demo.survey_log values(5,&#39;skip&#39;,369,null,2,126);--随机加了两行试一下insert into demo.survey_log values(5,&#39;show&#39;,286,null,1,123);insert into demo.survey_log values(5,&#39;answer&#39;,286,124124,1,124);我觉得网上的答案有个问题就是，如果只取一个LIMIT 1，会造成相同的回答率的结果只有一个。我个人不推荐，见网友Query：12345678910SELECT question_id AS &#39;survey_log&#39;FROM ( SELECT question_id, SUM(CASE WHEN action&#x3D;&#39;answer&#39; THEN 1 ELSE 0 END) AS num_answer, SUM(CASE WHEN action&#x3D;&#39;show&#39; THEN 1 ELSE 0 END) AS num_show FROM survey_log GROUP BY question_id ) AS tORDER BY (num_answer &#x2F; num_show) DESCLIMIT 0,1还有一种写法12345SELECT question_id AS survey_logFROM survey_logGROUP BY question_idORDER BY SUM(IF(action&#x3D;&#39;answer&#39;, 1, 0)) &#x2F; SUM(IF(action&#x3D;&#39;show&#39;, 1, 0)) DESCLIMIT 0,1;597. Friend Requests I: Overall Acceptance RateIn social network like Facebook or Twitter, people send friend requests and accept others’ requests as well. Now given two tables as below:Table: friend_request1234567891011121314151617| sender_id | send_to_id |request_date||-----------|------------|------------|| 1 | 2 | 2016_06-01 || 1 | 3 | 2016_06-01 || 1 | 4 | 2016_06-01 || 2 | 3 | 2016_06-02 || 3 | 4 | 2016-06-09 |Table: request_accepted| requester_id | accepter_id |accept_date ||--------------|-------------|------------|| 1 | 2 | 2016_06-03 || 1 | 3 | 2016-06-08 || 2 | 3 | 2016-06-08 || 3 | 4 | 2016-06-09 || 3 | 4 | 2016-06-10 |Write a query to find the overall acceptance rate of requests rounded to 2 decimals, which is the number of acceptance divide the number of requests.For the sample data above, your query should return the following result.123|accept_rate||-----------|| 0.80|Note:The accepted requests are not necessarily from the table friend_request. In this case, you just need to simply count the total accepted requests (no matter whether they are in the original requests), and divide it by the number of requests to get the acceptance rate.It is possible that a sender sends multiple requests to the same receiver, and a request could be accepted more than once. In this case, the ‘duplicated’ requests or acceptances are only counted once.If there is no requests at all, you should return 0.00 as the accept_rate.Explanation: There are 4 unique accepted requests, and there are 5 requests in total. So the rate is 0.80.Follow-up:Can you write a query to return the accept rate but for every month?How about the cumulative accept rate for every day?1234567ROUND( IFNULL( (SELECT count(*) FROM (SELECT DISTINCT requester_id, accepter_id FROM request_accepted) AS A) / (SELECT count(*) FROM (SELECT DISTINCT sender_id, send_to_id FROM friend_request) AS B) ,0),2) AS accept_ratecount( distinct col1 , col2 , col3 , .......) from table123456&#96;&#96;&#96;但是，这样是不允许的???，因为count是不能统计多个字段的，虽然distinct是可行的。有种比较直接的方法就是把消除重复后在统计查询:&#96;&#96;&#96;select count(*) from (select distinct col1 ,col2 , col3 from table)A但是，我的MYSQL版本可以的。https://dba.stackexchange.com/questions/127564/how-to-use-count-with-multiple-columns为了回答Follow Up题目，我亲测。1234567891011create table demo.request_accepted( requester_id int, accepter_id varchar(80), accept_date MEDIUMTEXT );insert into demo.request_accepted values(&#39;1&#39;,&#39;2&#39;,&#39;2016-06-03&#39;);insert into demo.request_accepted values(&#39;1&#39;,&#39;3&#39;,&#39;2016-06-08&#39;);insert into demo.request_accepted values(&#39;2&#39;,&#39;3&#39;,&#39;2016-06-08&#39;);insert into demo.request_accepted values(&#39;3&#39;,&#39;4&#39;,&#39;2016-06-09&#39;);insert into demo.request_accepted values(&#39;3&#39;,&#39;4&#39;,&#39;2016-06-10&#39;);Follow Up1.Can you write a query to return the accept rate but for every month?123456SELECT ROUND(IFNULL((A.accept_num/B.request_num),0),2) AS accept_rate, A.accept_m AS monthFROM(SELECT COUNT(DISTINCT requester_id, accepter_id) AS accept_num, MONTH(accept_date) AS accept_m FROM demo.request_accepted GROUP BY accept_m) A,(SELECT COUNT(DISTINCT sender_id, send_to_id) AS request_num, MONTH(request_date) AS request_m FROM demo.friend_request GROUP BY request_m) BWHERE A.accept_m = B.request_mGROUP BY A.accept_m;Result{“headers”: [“accept_rate”, “month”],“values”: [[0.80, 6]]}Follow-up 2: return the cumulative accept rate for every day12345678SELECT ROUND(COUNT(DISTINCT requester_id, accepter_id) / COUNT(DISTINCT sender_id, send_to_id),2) AS accept_rate, data_table.datesFROM demo.request_accepted acp, demo.friend_request req,(SELECT request_date AS dates FROM demo.friend_requestUNIONSELECT accept_date FROM demo.request_acceptedORDER BY dates) data_tableWHERE acp.accept_date &lt;= data_table.dates AND req.request_date &lt;= data_table.datesGROUP BY data_table.dates;Result{“headers”: [“rate”, “dates”],“values”: [[0.25, “2016-06-03”], [0.75, “2016-06-08”], [0.80, “2016-06-09”], [0.80, “2016-06-10”]]}大家自己写的时候可以把demo去掉。602. Friend Requests II: Who Has the Most FriendsIn social network like Facebook or Twitter, people send friend requests and accept others’ requests as well.Table request_accepted holds the data of friend acceptance, while requester_id and accepter_id both are the id of a person.12345678910111213| requester_id | accepter_id | accept_date||--------------|-------------|------------|| 1 | 2 | 2016_06-03 || 1 | 3 | 2016-06-08 || 2 | 3 | 2016-06-08 || 3 | 4 | 2016-06-09 |Write a query to find the the people who has most friends and the most friends number. For the sample data above, the result is:| id | num ||----|-----|| 3 | 3 |Note:It is guaranteed there is only 1 people having the most friends.The friend request could only been accepted once, which mean there is no multiple records with the same requester_id and accepter_id value.Explanation:The person with id ‘3’ is a friend of people ‘1’, ‘2’ and ‘4’, so he has 3 friends in total, which is the most number than any others.Follow-up:In the real world, multiple people could have the same most number of friends, can you find all these people in this case?123456789101112SELECT C.id, COUNT(C.id) AS numFROM(SELECT requester_id idFROM request_accepted AS AUNION ALLSELECT accepter_id idFROM request_accepted AS B) AS CGROUP BY C.idORDER BY COUNT(C.id) DESCLIMIT 1 OFFSET 0;Follow-Up: 这个无非就是再取个MAX，取出多个值。123456789101112131415161718192021222324SELECT C.id, COUNT(C.id) AS numFROM(SELECT requester_id idFROM request_accepted AS AUNION ALLSELECT accepter_id idFROM request_accepted AS B) AS CGROUP BY C.idHAVING COUNT(C.id) =(SELECT MAX(num)FROM(SELECT C.id, COUNT(C.id) AS numFROM(SELECT requester_id idFROM request_accepted AS AUNION ALLSELECT accepter_id idFROM request_accepted AS B) AS CGROUP BY C.id) AS D);614. Second Degree FollowerIn facebook, there is a follow table with two columns: followee, follower.Please write a sql query to get the amount of each follower’s follower if he/she has one.For example:1234567891011121314151617+-------------+------------+| followee | follower |+-------------+------------+| A | B || B | C || B | D || D | E |+-------------+------------+should output:+-------------+------------+| follower | num |+-------------+------------+| B | 2 || D | 1 |+-------------+------------+Explaination:Both B and D exist in the follower list, when as a followee, B&#39;s follower is C and D, and D&#39;s follower is E. A does not exist in follower list.Note:Followee would not follow himself/herself in all cases.Please display the result in follower’s alphabet order.这个方法Leetcode好像过不了，无奈，还是用土办法吧。1234SELECT f.followee AS follower, COUNT(f.followee) AS numFROM demo.follower fWHERE f.followee in (SELECT follower FROM demo.follower)GROUP BY f.followee;还是土办法保险：连接两张follow表格。让第二张表的被关注者（followee）等于第一张表的关注者（follower），则第二张表的关注者（follower）就是第一张表关注者的关注者。然后根据第一张表的关注者（follower）分组，对于每组统计第二张表中关注者（follower）的数量。最后排除重复记录，并按照第一张表中关注者（follower）的字母表顺序排序。12345SELECT A.follower, COUNT(DISTINCT B.follower) AS numFROM demo.follower AINNER JOIN demo.follower BON A.follower = B.followeeGROUP BY A.follower;参考：https://nifannn.github.io/2018/06/17/SQL-%E7%AC%94%E8%AE%B0-Leetcode-614-Second-Degree-Follower/1075. Project Employees ITable: Project123456+-------------+---------+| Column Name | Type |+-------------+---------+| project_id | int || employee_id | int |+-------------+---------+(project_id, employee_id) is the primary key of this table.employee_id is a foreign key to Employee table.Table: Employee12345678910111213141516171819202122232425262728293031323334353637383940414243+------------------+---------+| Column Name | Type |+------------------+---------+| employee_id | int || name | varchar || experience_years | int |+------------------+---------+employee_id is the primary key of this table.Write an SQL query that reports the average experience years of all the employees for each project, rounded to 2 digits.The query result format is in the following example:Project table:+-------------+-------------+| project_id | employee_id |+-------------+-------------+| 1 | 1 || 1 | 2 || 1 | 3 || 2 | 1 || 2 | 4 |+-------------+-------------+Employee table:+-------------+--------+------------------+| employee_id | name | experience_years |+-------------+--------+------------------+| 1 | Khaled | 3 || 2 | Ali | 2 || 3 | John | 1 || 4 | Doe | 2 |+-------------+--------+------------------+Result table:+-------------+---------------+| project_id | average_years |+-------------+---------------+| 1 | 2.00 || 2 | 2.50 |+-------------+---------------+The average experience years for the first project is (3 + 2 + 1) &#x2F; 3 &#x3D; 2.00 and for the second project is (3 + 2) &#x2F; 2 &#x3D; 2.5012345SELECT project_id,ROUND(AVG(experience_years),2) AS average_yearsFROM Project pLEFT JOIN Employee ep.employee_id = e.employee_idGROUP BY projected_id1076. Project Employees IITable: Project12345678+-------------+---------+| Column Name | Type |+-------------+---------+| project_id | int || employee_id | int |+-------------+---------+(project_id, employee_id) is the primary key of this table.employee_id is a foreign key to Employee table.Table: Employee12345678+------------------+---------+| Column Name | Type |+------------------+---------+| employee_id | int || name | varchar || experience_years | int |+------------------+---------+employee_id is the primary key of this table.Write an SQL query that reports all the projects that have the most employees.The query result format is in the following example:1234567891011121314151617181920212223242526272829Project table:+-------------+-------------+| project_id | employee_id |+-------------+-------------+| 1 | 1 || 1 | 2 || 1 | 3 || 2 | 1 || 2 | 4 |+-------------+-------------+Employee table:+-------------+--------+------------------+| employee_id | name | experience_years |+-------------+--------+------------------+| 1 | Khaled | 3 || 2 | Ali | 2 || 3 | John | 1 || 4 | Doe | 2 |+-------------+--------+------------------+Result table:+-------------+| project_id |+-------------+| 1 |+-------------+The first project has 3 employees while the second one has 2.网上标准答案12345678910111213141516171819SELECT project_idFROM ProjectGROUP BY project_idHAVING COUNT(employee_id) = (SELECT COUNT(employee_id) FROM Project GROUP BY project_id ORDER BY COUNT(employee_id) DESC LIMIT 1)``` 我觉得我这么写也无所谓，就是一种情况，那就是多个项目人数一样多，我的写法就有问题啦。当然肯定还是上面一种办法保险。```sqlSELECT project_idFROM(SELECT project_id, count(employee_id) AS numFROM demo.project pGROUP BY project_idORDER BY count(employee_id) DESCLIMIT 1) sub;1077. Project Employees IIITable: Project123456789101112131415161718+-------------+---------+| Column Name | Type |+-------------+---------+| project_id | int || employee_id | int |+-------------+---------+(project_id, employee_id) is the primary key of this table.employee_id is a foreign key to Employee table.Table: Employee+------------------+---------+| Column Name | Type |+------------------+---------+| employee_id | int || name | varchar || experience_years | int |+------------------+---------+employee_id is the primary key of this table.Write an SQL query that reports the most experienced employees in each project. In case of a tie, report all employees with the maximum number of experience years.The query result format is in the following example:123456789101112131415161718192021222324252627282930Project table:+-------------+-------------+| project_id | employee_id |+-------------+-------------+| 1 | 1 || 1 | 2 || 1 | 3 || 2 | 1 || 2 | 4 |+-------------+-------------+Employee table:+-------------+--------+------------------+| employee_id | name | experience_years |+-------------+--------+------------------+| 1 | Khaled | 3 || 2 | Ali | 2 || 3 | John | 3 || 4 | Doe | 2 |+-------------+--------+------------------+Result table:+-------------+---------------+| project_id | employee_id |+-------------+---------------+| 1 | 1 || 1 | 3 || 2 | 1 |+-------------+---------------+Both employees with id 1 and 3 have the most experience among the employees of the first project. For the second project, the employee with id 1 has the most experience.1234567891011SELECT P.project_id, E.employee_idFROM Project AS P LEFT JOIN Employee AS EON P.employee_id = E.employee_idWHERE (P.project_id, E.experience_years) IN ( SELECT P.project_id, MAX(E.experience_years) FROM Project AS P LEFT JOIN Employee AS E ON P.employee_id = E.employee_id GROUP BY P.project_id );或者用inner笨办法：1234567891011SELECT A.project_id, A.employee_idFROM demo.project AS ALEFT JOIN demo.Employee AS BON A.employee_id = B.employee_idINNER JOIN(SELECT project_id, MAX(experience_years) AS experience_yearsFROM demo.project pLEFT JOIN demo.Employee eON p.employee_id = e.employee_idGROUP BY project_id) AS CON A.project_id = C.project_id AND B.experience_years = C.experience_years;1113. Reported PostsTable: Actions123456789101112+---------------+---------+| Column Name | Type |+---------------+---------+| user_id | int || post_id | int || action_date | date || action | enum || extra | varchar |+---------------+---------+There is no primary key for this table, it may have duplicate rows.The action column is an ENUM type of (&#39;view&#39;, &#39;like&#39;, &#39;reaction&#39;, &#39;comment&#39;, &#39;report&#39;, &#39;share&#39;).The extra column has optional information about the action such as a reason for report or a type of reaction.Write an SQL query that reports the number of posts reported yesterday for each report reason. Assume today is 2019-07-05.The query result format is in the following example:Actions table:1234567891011121314151617181920212223242526+---------+---------+-------------+--------+--------+| user_id | post_id | action_date | action | extra |+---------+---------+-------------+--------+--------+| 1 | 1 | 2019-07-01 | view | null || 1 | 1 | 2019-07-01 | like | null || 1 | 1 | 2019-07-01 | share | null || 2 | 4 | 2019-07-04 | view | null || 2 | 4 | 2019-07-04 | report | spam || 3 | 4 | 2019-07-04 | view | null || 3 | 4 | 2019-07-04 | report | spam || 4 | 3 | 2019-07-02 | view | null || 4 | 3 | 2019-07-02 | report | spam || 5 | 2 | 2019-07-04 | view | null || 5 | 2 | 2019-07-04 | report | racism || 5 | 5 | 2019-07-04 | view | null || 5 | 5 | 2019-07-04 | report | racism |+---------+---------+-------------+--------+--------+Result table:+---------------+--------------+| report_reason | report_count |+---------------+--------------+| spam | 1 || racism | 2 |+---------------+--------------+Note that we only care about report reasons with non zero number of reports.12345SELECT extra as report_reason, COUNT(DISTINCT post_id) AS report_countFROM ActionWHERE action='report' AND DATEDIFF('2019-07-05',action_date) = 1GROUP BY extraHAVING COUNT(DISTINCT post_id) &gt; 0;1132. Reported Posts IITable: Actions12345678910111213141516171819202122+---------------+---------+| Column Name | Type |+---------------+---------+| user_id | int || post_id | int || action_date | date || action | enum || extra | varchar |+---------------+---------+There is no primary key for this table, it may have duplicate rows.The action column is an ENUM type of (&#39;view&#39;, &#39;like&#39;, &#39;reaction&#39;, &#39;comment&#39;, &#39;report&#39;, &#39;share&#39;).The extra column has optional information about the action such as a reason for report or a type of reaction.Table: Removals+---------------+---------+| Column Name | Type |+---------------+---------+| post_id | int || remove_date | date |+---------------+---------+post_id is the primary key of this table.Each row in this table indicates that some post was removed as a result of being reported or as a result of an admin review.Write an SQL query to find the average for daily percentage of posts that got removed after being reported as spam, rounded to 2 decimal places.The query result format is in the following example:12345678910111213141516171819202122232425262728293031323334353637Actions table:+---------+---------+-------------+--------+--------+| user_id | post_id | action_date | action | extra |+---------+---------+-------------+--------+--------+| 1 | 1 | 2019-07-01 | view | null || 1 | 1 | 2019-07-01 | like | null || 1 | 1 | 2019-07-01 | share | null || 2 | 2 | 2019-07-04 | view | null || 2 | 2 | 2019-07-04 | report | spam || 3 | 4 | 2019-07-04 | view | null || 3 | 4 | 2019-07-04 | report | spam || 4 | 3 | 2019-07-02 | view | null || 4 | 3 | 2019-07-02 | report | spam || 5 | 2 | 2019-07-03 | view | null || 5 | 2 | 2019-07-03 | report | racism || 5 | 5 | 2019-07-03 | view | null || 5 | 5 | 2019-07-03 | report | racism |+---------+---------+-------------+--------+--------+Removals table:+---------+-------------+| post_id | remove_date |+---------+-------------+| 2 | 2019-07-20 || 3 | 2019-07-18 |+---------+-------------+Result table:+-----------------------+| average_daily_percent |+-----------------------+| 75.00 |+-----------------------+The percentage for 2019-07-04 is 50% because only one post of two spam reported posts was removed.The percentage for 2019-07-02 is 100% because one post was reported as spam and it was removed.The other days had no spam reports so the average is (50 + 100) &#x2F; 2 &#x3D; 75%Note that the output is only one number and that we do not care about the remove dates.1234567891011121314151617181920212223create table demo.Actions( user_id int, post_id int, action_date MEDIUMTEXT, action varchar(20), extra varchar(20) );insert into demo.Actions (user_id, post_id, action_date, action, extra) values (&#39;1&#39;, &#39;1&#39;, &#39;2019-07-01&#39;, &#39;view&#39;, &#39;None&#39;);insert into demo.Actions (user_id, post_id, action_date, action, extra) values (&#39;1&#39;, &#39;1&#39;, &#39;2019-07-01&#39;, &#39;like&#39;, &#39;None&#39;);insert into demo.Actions (user_id, post_id, action_date, action, extra) values (&#39;1&#39;, &#39;1&#39;, &#39;2019-07-01&#39;, &#39;share&#39;, &#39;None&#39;);insert into demo.Actions (user_id, post_id, action_date, action, extra) values (&#39;2&#39;, &#39;2&#39;, &#39;2019-07-04&#39;, &#39;view&#39;, &#39;None&#39;);insert into demo.Actions (user_id, post_id, action_date, action, extra) values (&#39;2&#39;, &#39;2&#39;, &#39;2019-07-04&#39;, &#39;report&#39;, &#39;spam&#39;);insert into demo.Actions (user_id, post_id, action_date, action, extra) values (&#39;3&#39;, &#39;4&#39;, &#39;2019-07-04&#39;, &#39;view&#39;, &#39;None&#39;);insert into demo.Actions (user_id, post_id, action_date, action, extra) values (&#39;3&#39;, &#39;4&#39;, &#39;2019-07-04&#39;, &#39;report&#39;, &#39;spam&#39;);insert into demo.Actions (user_id, post_id, action_date, action, extra) values (&#39;4&#39;, &#39;3&#39;, &#39;2019-07-02&#39;, &#39;view&#39;, &#39;None&#39;);insert into demo.Actions (user_id, post_id, action_date, action, extra) values (&#39;4&#39;, &#39;3&#39;, &#39;2019-07-02&#39;, &#39;report&#39;, &#39;spam&#39;);insert into demo.Actions (user_id, post_id, action_date, action, extra) values (&#39;5&#39;, &#39;2&#39;, &#39;2019-07-03&#39;, &#39;view&#39;, &#39;None&#39;);insert into demo.Actions (user_id, post_id, action_date, action, extra) values (&#39;5&#39;, &#39;2&#39;, &#39;2019-07-03&#39;, &#39;report&#39;, &#39;racism&#39;);insert into demo.Actions (user_id, post_id, action_date, action, extra) values (&#39;5&#39;, &#39;5&#39;, &#39;2019-07-03&#39;, &#39;view&#39;, &#39;None&#39;);insert into demo.Actions (user_id, post_id, action_date, action, extra) values (&#39;5&#39;, &#39;5&#39;, &#39;2019-07-03&#39;, &#39;report&#39;, &#39;racism&#39;);insert into demo.Actions (user_id, post_id, action_date, action, extra) values (&#39;6&#39;, &#39;6&#39;, &#39;2019-07-10&#39;, &#39;report&#39;, &#39;spam&#39;);1SELECT * FROM demo.Actions;123456789create table demo.Removals( post_id int, remove_date MEDIUMTEXT );insert into demo.Removals values (&#39;2&#39;, &#39;2019-07-20&#39;);insert into demo.Removals values (&#39;3&#39;, &#39;2019-07-18&#39;);insert into demo.Removals values (&#39;5&#39;, &#39;2019-07-30&#39;);Solution:12345678910111213SELECT ROUND(100*avg(IFNULL(num_remove,0)/num_spam),2)as average_daily_percentFROM(SELECT COUNT(DISTINCT(post_id)) as num_spam, action_dateFROM demo.ActionsWHERE action = 'report' AND extra = 'spam'GROUP BY action_date) ALEFT JOIN(SELECT COUNT(DISTINCT(post_id)) num_remove, action_dateFROM demo.ActionsWHERE action = 'report' AND extra = 'spam' AND post_id in (SELECT post_id FROM demo.Removals)GROUP BY action_date) BON A.action_date = B.action_date;这里加null的原因是action表格如果有report spam 但是没有处理的，这样合并会产生null值，但是其实avg以后不会count那行null值，没有关系。这道题目重点是要算清楚分子，分母，再加上left join 合并。https://zhuanlan.zhihu.com/p/945751591141. User Activity for the Past 30 Days ITable: Activity123456789101112+---------------+---------+| Column Name | Type |+---------------+---------+| user_id | int || session_id | int || activity_date | date || activity_type | enum |+---------------+---------+There is no primary key for this table, it may have duplicate rows.The activity_type column is an ENUM of type (&#39;open_session&#39;, &#39;end_session&#39;, &#39;scroll_down&#39;, &#39;send_message&#39;).The table shows the user activities for a social media website.Note that each session belongs to exactly one user.Write an SQL query to find the daily active user count for a period of 30 days ending 2019-07-27 inclusively. A user was active on some day if he/she made at least one activity on that day.The query result format is in the following example:Activity table:123456789101112131415161718192021222324+---------+------------+---------------+---------------+| user_id | session_id | activity_date | activity_type |+---------+------------+---------------+---------------+| 1 | 1 | 2019-07-20 | open_session || 1 | 1 | 2019-07-20 | scroll_down || 1 | 1 | 2019-07-20 | end_session || 2 | 4 | 2019-07-20 | open_session || 2 | 4 | 2019-07-21 | send_message || 2 | 4 | 2019-07-21 | end_session || 3 | 2 | 2019-07-21 | open_session || 3 | 2 | 2019-07-21 | send_message || 3 | 2 | 2019-07-21 | end_session || 4 | 3 | 2019-06-25 | open_session || 4 | 3 | 2019-06-25 | end_session |+---------+------------+---------------+---------------+Result table:+------------+--------------+| day | active_users |+------------+--------------+| 2019-07-20 | 2 || 2019-07-21 | 2 |+------------+--------------+Note that we do not care about days with zero active users.1234SELECT activity_date AS day, COUNT(DISTINCT user_id) AS active_usersFROM ActivityWHERE activity_date between date_sub('2019-07-27', interval 30 day) AND '2019-07-27'GROUP BY day;1142. User Activity for the Past 30 Days IITable: Activity123456789101112+---------------+---------+| Column Name | Type |+---------------+---------+| user_id | int || session_id | int || activity_date | date || activity_type | enum |+---------------+---------+There is no primary key for this table, it may have duplicate rows.The activity_type column is an ENUM of type (&#39;open_session&#39;, &#39;end_session&#39;, &#39;scroll_down&#39;, &#39;send_message&#39;).The table shows the user activities for a social media website.Note that each session belongs to exactly one user.Write an SQL query to find the average number of sessions per user for a period of 30 days ending 2019-07-27 inclusively, rounded to 2 decimal places. The sessions we want to count for a user are those with at least one activity in that time period.The query result format is in the following example:123456789101112131415161718192021222324252627Activity table:+---------+------------+---------------+---------------+| user_id | session_id | activity_date | activity_type |+---------+------------+---------------+---------------+| 1 | 1 | 2019-07-20 | open_session || 1 | 1 | 2019-07-20 | scroll_down || 1 | 1 | 2019-07-20 | end_session || 2 | 4 | 2019-07-20 | open_session || 2 | 4 | 2019-07-21 | send_message || 2 | 4 | 2019-07-21 | end_session || 3 | 2 | 2019-07-21 | open_session || 3 | 2 | 2019-07-21 | send_message || 3 | 2 | 2019-07-21 | end_session || 3 | 5 | 2019-07-21 | open_session || 3 | 5 | 2019-07-21 | scroll_down || 3 | 5 | 2019-07-21 | end_session || 4 | 3 | 2019-06-25 | open_session || 4 | 3 | 2019-06-25 | end_session |+---------+------------+---------------+---------------+Result table:+---------------------------+| average_sessions_per_user |+---------------------------+| 1.33 |+---------------------------+User 1 and 2 each had 1 session in the past 30 days while user 3 had 2 sessions so the average is (1 + 1 + 2) &#x2F; 3 &#x3D; 1.33.WAY1:123456SELECT ROUND(IFNULL(AVG(num_session),0),2) AS average_session_per_userFROM(SELECT COUNT(DISTINCT session_id) AS num_sessionFROM ActivityWHERE (activity_date between DATE_SUB('2019-07-27', INTERVAL 30 DAY) and '2019-07-27') AND activity_type in ('scroll_down', 'send_message')GROUP BY user_id) AS subWAY2:123SELECT ROUND(IFNULL(COUNT(DISTINCT session_id) / COUNT(DISTINCT user_id),0),2) AS average_session_per_userFROM ActivityWHERE (activity_date between DATE_SUB('2019-07-27', INTERVAL 30 DAY) and '2019-07-27') AND activity_type in ('scroll_down', 'send_message');","categories":[{"name":"Database","slug":"Database","permalink":"http://yoursite.com/categories/Database/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/tags/Leetcode/"},{"name":"Facebook","slug":"Facebook","permalink":"http://yoursite.com/tags/Facebook/"}]},{"title":"SQL-exercises-in-LeetCode-easy-part","slug":"SQL-exercises-in-LeetCode-easy-part","date":"2020-06-18T02:38:36.000Z","updated":"2020-06-23T03:12:29.878Z","comments":true,"path":"2020/06/17/SQL-exercises-in-LeetCode-easy-part/","link":"","permalink":"http://yoursite.com/2020/06/17/SQL-exercises-in-LeetCode-easy-part/","excerpt":"LeetCode中的sql练习题-easy难度部分新增本文包含LeetCode中easy难度的sql练习题的解题思路和通过代码，关于题目描述可以查看leetcode原网站，或者leetcode中文网站。此文章仅用于个人学习记录，请勿用于商业用途。This article contains the solution ideas of practice questions in LeetCode. For the description of the question, you can check the original website of leetcode. This article is only for personal learning purposes, please do not use it for commercial purposes.","text":"LeetCode中的sql练习题-easy难度部分新增本文包含LeetCode中easy难度的sql练习题的解题思路和通过代码，关于题目描述可以查看leetcode原网站，或者leetcode中文网站。此文章仅用于个人学习记录，请勿用于商业用途。This article contains the solution ideas of practice questions in LeetCode. For the description of the question, you can check the original website of leetcode. This article is only for personal learning purposes, please do not use it for commercial purposes.其他部分，请见这位同学的作业 https://huanyouchen.github.io/2019/09/11/SQL-exercises-in-LeetCode-easy-part/我懒得放上来了。1241. Number of Comments per PostTable: Submissions12345678910+---------------+----------+| Column Name | Type |+---------------+----------+| sub_id | int || parent_id | int |+---------------+----------+There is no primary key for this table, it may have duplicate rows.Each row can be a post or comment on the post.parent_id is null for posts.parent_id for comments is sub_id for another post in the table.Write an SQL query to find number of comments per each post.Result table should contain post_id and its corresponding number_of_comments, and must be sorted by post_id in ascending order.Submissions may contain duplicate comments. You should count the number of unique comments per post.Submissions may contain duplicate posts. You should treat them as one post.The query result format is in the following example:123456789101112131415161718192021222324252627282930Submissions table:+---------+------------+| sub_id | parent_id |+---------+------------+| 1 | Null || 2 | Null || 1 | Null || 12 | Null || 3 | 1 || 5 | 2 || 3 | 1 || 4 | 1 || 9 | 1 || 10 | 2 || 6 | 7 |+---------+------------+Result table:+---------+--------------------+| post_id | number_of_comments |+---------+--------------------+| 1 | 3 || 2 | 2 || 12 | 0 |+---------+--------------------+The post with id 1 has three comments in the table with id 3, 4 and 9. The comment with id 3 is repeated in the table, we counted it only once.The post with id 2 has two comments in the table with id 5 and 10.The post with id 12 has no comments in the table.The comment with id 6 is a comment on a deleted post with id 7 so we ignored it.Solution:这道题的难点在于彻彻底底考察了JOIN的功底LEFT JOIN 写法1234SELECT DISTINCT A.sub_id, COUNT(DISTINCT B.sub_id) AS number_of_commentsFROM demo.sub AS A LEFT JOIN demo.sub AS B ON A.sub_id = B.parent_idWHERE A.parent_id is nullGROUP by A.sub_id;更简洁的LEFT JOIN123SELECT post_id, COUNT(DISTINCT B.sub_id) AS number_of_commentsFROM (SELECT DISTINCT sub_id AS post_id FROM demo.sub WHERE parent_id is null) AS A LEFT JOIN demo.sub AS B ON post_id = B.parent_idGROUP by post_id;RIGHT JOIN:123456789SELECT p.post_id, COUNT(DISTINCT(s.sub_id)) AS number_of_commentsFROM Submissions AS sRIGHT JOIN( SELECT DISTINCT(sub_id) as post_id FROM Submissions WHERE parent_id IS NULL)AS pON p.post_id = s.parent_idGROUP BY p.post_id1241. Number of Comments per PostTable: Submissions12345678910+---------------+----------+| Column Name | Type |+---------------+----------+| sub_id | int || parent_id | int |+---------------+----------+There is no primary key for this table, it may have duplicate rows.Each row can be a post or comment on the post.parent_id is null for posts.parent_id for comments is sub_id for another post in the table.Write an SQL query to find number of comments per each post.Result table should contain post_id and its corresponding number_of_comments, and must be sorted by post_id in ascending order.Submissions may contain duplicate comments. You should count the number of unique comments per post.Submissions may contain duplicate posts. You should treat them as one post.The query result format is in the following example:123456789101112131415161718192021222324252627282930Submissions table:+---------+------------+| sub_id | parent_id |+---------+------------+| 1 | Null || 2 | Null || 1 | Null || 12 | Null || 3 | 1 || 5 | 2 || 3 | 1 || 4 | 1 || 9 | 1 || 10 | 2 || 6 | 7 |+---------+------------+Result table:+---------+--------------------+| post_id | number_of_comments |+---------+--------------------+| 1 | 3 || 2 | 2 || 12 | 0 |+---------+--------------------+The post with id 1 has three comments in the table with id 3, 4 and 9. The comment with id 3 is repeated in the table, we counted it only once.The post with id 2 has two comments in the table with id 5 and 10.The post with id 12 has no comments in the table.The comment with id 6 is a comment on a deleted post with id 7 so we ignored it.Solution:123456SELECT P.product_id, ROUND(P.price * U.unit / SUM (U.units),2) AS average_priceFROM Prices PINNER JOIN UnitsSold UON P.product_id = U.product_idWHERE U.purchase_date BETWEEN P.start_date AND P.end_dateGROUP BY P.product_id;1280. Students and ExaminationsSQL SchemaTable: Students12345678+---------------+---------+| Column Name | Type |+---------------+---------+| student_id | int || student_name | varchar |+---------------+---------+student_id is the primary key for this table.Each row of this table contains the ID and the name of one student in the school.Table: Subjects1234567+--------------+---------+| Column Name | Type |+--------------+---------+| subject_name | varchar |+--------------+---------+subject_name is the primary key for this table.Each row of this table contains a name of one subject in the school.Table: Examinations123456789+--------------+---------+| Column Name | Type |+--------------+---------+| student_id | int || subject_name | varchar |+--------------+---------+There is no primary key for this table. It may contain duplicates.Each student from Students table takes every course from Subjects table.Each row of this table indicates that a student with ID student_id attended the exam of subject_name.Write an SQL query to find the number of times each student attended each exam.Order the result table by student_id and subject_name.The query result format is in the following example:Students table:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556+------------+--------------+| student_id | student_name |+------------+--------------+| 1 | Alice || 2 | Bob || 13 | John || 6 | Alex |+------------+--------------+Subjects table:+--------------+| subject_name |+--------------+| Math || Physics || Programming |+--------------+Examinations table:+------------+--------------+| student_id | subject_name |+------------+--------------+| 1 | Math || 1 | Physics || 1 | Programming || 2 | Programming || 1 | Physics || 1 | Math || 13 | Math || 13 | Programming || 13 | Physics || 2 | Math || 1 | Math |+------------+--------------+Result table:+------------+--------------+--------------+----------------+| student_id | student_name | subject_name | attended_exams |+------------+--------------+--------------+----------------+| 1 | Alice | Math | 3 || 1 | Alice | Physics | 2 || 1 | Alice | Programming | 1 || 2 | Bob | Math | 1 || 2 | Bob | Physics | 0 || 2 | Bob | Programming | 1 || 6 | Alex | Math | 0 || 6 | Alex | Physics | 0 || 6 | Alex | Programming | 0 || 13 | John | Math | 1 || 13 | John | Physics | 1 || 13 | John | Programming | 1 |+------------+--------------+--------------+----------------+The result table should contain all students and all subjects.Alice attended Math exam 3 times,Physics exam 2 times and Programming exam 1 time.Bob attended Math exam 1 time, Programming exam 1 time and didn&#39;t attend the Physics exam.Alex didn&#39;t attend any exam.John attended Math exam 1 time, Physics exam 1 time and Programming exam 1 time.思路: Cross Join 和inner join 没区别这里，原来三个table可以直接先写好 再写ON12345678SELECT S.student_id, S.student_name, B.subject_name, count(E.subject_name) AS attended_examsFROM Students SINNER JOIN Subjects BLEFT JOIN Examinations EON S.student_id = E.student_id AND E.subject_name = B.subject_nameGROUP BY S.student_id, S.student_name, B.subject_nameORDER BY S.student_id, S.student_name, B.subject_name;CROSS JOIN 结果一样的，过程稍微有点区别。先连结两个表：对表Students和表Subjects求笛卡尔积，得到4*3行的表，再连结三个表：对刚刚得到的新表和表Examinations进行左连结（LEFT JOIN）我看到这边几个博主省略了一列在GROUP BY里面 见CSDN网友还有 YouTube博主123456SELECT a.student_id, a.student_name, b.subject_name, COUNT(e.subject_name) AS attended_examsFROM demo.Students1 a CROSS JOIN demo.Subjects bLEFT JOIN demo.Examinations eON a.student_id = e.student_id AND b.subject_name = e.subject_nameGROUP BY a.student_id, a.student_name, b.subject_nameORDER BY a.student_id, a.student_name, b.subject_name;1294. Weather Type in Each CountrySQL SchemaTable: Countries12345678+---------------+---------+| Column Name | Type |+---------------+---------+| country_id | int || country_name | varchar |+---------------+---------+country_id is the primary key for this table.Each row of this table contains the ID and the name of one country.Table: Weather123456789+---------------+---------+| Column Name | Type |+---------------+---------+| country_id | int || weather_state | varchar || day | date |+---------------+---------+(country_id, day) is the primary key for this table.Each row of this table indicates the weather state in a country for one day.Write an SQL query to find the type of weather in each country for November 2019.The type of weather is Cold if the average weather_state is less than or equal 15, Hot if the average weather_state is greater than or equal 25 and Warm otherwise.Return result table in any order.The query result format is in the following example:Countries table:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748+------------+--------------+| country_id | country_name |+------------+--------------+| 2 | USA || 3 | Australia || 7 | Peru || 5 | China || 8 | Morocco || 9 | Spain |+------------+--------------+Weather table:+------------+---------------+------------+| country_id | weather_state | day |+------------+---------------+------------+| 2 | 15 | 2019-11-01 || 2 | 12 | 2019-10-28 || 2 | 12 | 2019-10-27 || 3 | -2 | 2019-11-10 || 3 | 0 | 2019-11-11 || 3 | 3 | 2019-11-12 || 5 | 16 | 2019-11-07 || 5 | 18 | 2019-11-09 || 5 | 21 | 2019-11-23 || 7 | 25 | 2019-11-28 || 7 | 22 | 2019-12-01 || 7 | 20 | 2019-12-02 || 8 | 25 | 2019-11-05 || 8 | 27 | 2019-11-15 || 8 | 31 | 2019-11-25 || 9 | 7 | 2019-10-23 || 9 | 3 | 2019-12-23 |+------------+---------------+------------+Result table:+--------------+--------------+| country_name | weather_type |+--------------+--------------+| USA | Cold || Austraila | Cold || Peru | Hot || China | Warm || Morocco | Hot |+--------------+--------------+Average weather_state in USA in November is (15) &#x2F; 1 &#x3D; 15 so weather type is Cold.Average weather_state in Austraila in November is (-2 + 0 + 3) &#x2F; 3 &#x3D; 0.333 so weather type is Cold.Average weather_state in Peru in November is (25) &#x2F; 1 &#x3D; 25 so weather type is Hot.Average weather_state in China in November is (16 + 18 + 21) &#x2F; 3 &#x3D; 18.333 so weather type is Warm.Average weather_state in Morocco in November is (25 + 27 + 31) &#x2F; 3 &#x3D; 27.667 so weather type is Hot.We know nothing about average weather_state in Spain in November so we don&#39;t include it in the result table.123456789SELECT country_name, CASE WHEN AVG(weather_state) &lt;= 15 THEN 'Cold' WHEN AVG(weather_state) &gt;= 25 THEN 'Hot' ELSE 'Warm' END AS weather_typeFROM Countries CLEFT JOIN Weather WON C.country_id = W.country_idWHERE W.day between '2019-11-01' and '2019-11-31'GROUP BY country_name) sub;1303. Find the Team Size 亚麻SQL SchemaTable: Employee1234567891011+---------------+---------+| Column Name | Type |+---------------+---------+| employee_id | int || team_id | int |+---------------+---------+employee_id is the primary key for this table.Each row of this table contains the ID of each employee and their respective team.Write an SQL query to find the team size of each of the employees.Return result table in any order.The query result format is in the following example:Employee Table:123456789101112131415161718192021222324+-------------+------------+| employee_id | team_id |+-------------+------------+| 1 | 8 || 2 | 8 || 3 | 8 || 4 | 7 || 5 | 9 || 6 | 9 |+-------------+------------+Result table:+-------------+------------+| employee_id | team_size |+-------------+------------+| 1 | 3 || 2 | 3 || 3 | 3 || 4 | 1 || 5 | 2 || 6 | 2 |+-------------+------------+Employees with Id 1,2,3 are part of a team with team_id &#x3D; 8.Employees with Id 4 is part of a team with team_id &#x3D; 7.Employees with Id 5,6 are part of a team with team_id &#x3D; 9.123456SELECT A.employee_id, B.team_sizeFROM Employee AS ALEFT JOIN (SELECT team_id, count(employee_id) as team_sizeFROM EmployeeGROUP BY team_id) AS BON A.team_id = B.team_id1322. Ads Performance FBSQL SchemaTable: Ads12345678910+---------------+---------+| Column Name | Type |+---------------+---------+| ad_id | int || user_id | int || action | enum |+---------------+---------+(ad_id, user_id) is the primary key for this table.Each row of this table contains the ID of an Ad, the ID of a user and the action taken by this user regarding this Ad.The action column is an ENUM type of (&#39;Clicked&#39;, &#39;Viewed&#39;, &#39;Ignored&#39;).A company is running Ads and wants to calculate the performance of each Ad.Performance of the Ad is measured using Click-Through Rate (CTR) where:CTR这里的定义是 Ad total clicks/(Ad total clicks + Ad total views)x100 具体面试和面试官确认Write an SQL query to find the ctr of each Ad.Round ctr to 2 decimal points. Order the result table by ctr in descending order and by ad_id in ascending order in case of a tie.The query result format is in the following example:Ads table:1234567891011121314151617181920212223242526272829+-------+---------+---------+| ad_id | user_id | action |+-------+---------+---------+| 1 | 1 | Clicked || 2 | 2 | Clicked || 3 | 3 | Viewed || 5 | 5 | Ignored || 1 | 7 | Ignored || 2 | 7 | Viewed || 3 | 5 | Clicked || 1 | 4 | Viewed || 2 | 11 | Viewed || 1 | 2 | Clicked |+-------+---------+---------+Result table:+-------+-------+| ad_id | ctr |+-------+-------+| 1 | 66.67 || 3 | 50.00 || 2 | 33.33 || 5 | 0.00 |+-------+-------+for ad_id &#x3D; 1, ctr &#x3D; (2&#x2F;(2+1)) * 100 &#x3D; 66.67for ad_id &#x3D; 2, ctr &#x3D; (1&#x2F;(1+2)) * 100 &#x3D; 33.33for ad_id &#x3D; 3, ctr &#x3D; (1&#x2F;(1+1)) * 100 &#x3D; 50.00for ad_id &#x3D; 5, ctr &#x3D; 0.00, Note that ad_id &#x3D; 5 has no clicks or views.Note that we don&#39;t care about Ignored Ads.Result table is ordered by the ctr. in case of a tie we order them by ad_id12345SELECT ad_id, IFNULL(ROUND(100*SUM(action='Clicked')/(SUM(action='Clicked')+SUM(action='Viewed')),2),0) AS ctrFROM AdsWHERE action in ('Clicked','Viewed')GROUP BY ad_idORDER BY ctr DESC, ad_id ASC;1327. List the Products Ordered in a Period 亚麻SQL SchemaTable: Products123456789+------------------+---------+| Column Name | Type |+------------------+---------+| product_id | int || product_name | varchar || product_category | varchar |+------------------+---------+product_id is the primary key for this table.This table contains data about the company&#39;s products.Table: Orders12345678910+---------------+---------+| Column Name | Type |+---------------+---------+| product_id | int || order_date | date || unit | int |+---------------+---------+There is no primary key for this table. It may have duplicate rows.product_id is a foreign key to Products table.unit is the number of products ordered in order_date.Write an SQL query to get the names of products with greater than or equal to 100 units ordered in February 2020 and their amount.Return result table in any order.The query result format is in the following example:Products table:1234567891011121314151617181920212223242526272829303132333435363738394041+-------------+-----------------------+------------------+| product_id | product_name | product_category |+-------------+-----------------------+------------------+| 1 | Leetcode Solutions | Book || 2 | Jewels of Stringology | Book || 3 | HP | Laptop || 4 | Lenovo | Laptop || 5 | Leetcode Kit | T-shirt |+-------------+-----------------------+------------------+Orders table:+--------------+--------------+----------+| product_id | order_date | unit |+--------------+--------------+----------+| 1 | 2020-02-05 | 60 || 1 | 2020-02-10 | 70 || 2 | 2020-01-18 | 30 || 2 | 2020-02-11 | 80 || 3 | 2020-02-17 | 2 || 3 | 2020-02-24 | 3 || 4 | 2020-03-01 | 20 || 4 | 2020-03-04 | 30 || 4 | 2020-03-04 | 60 || 5 | 2020-02-25 | 50 || 5 | 2020-02-27 | 50 || 5 | 2020-03-01 | 50 |+--------------+--------------+----------+Result table:+--------------------+---------+| product_name | unit |+--------------------+---------+| Leetcode Solutions | 130 || Leetcode Kit | 100 |+--------------------+---------+Products with product_id &#x3D; 1 is ordered in February a total of (60 + 70) &#x3D; 130.Products with product_id &#x3D; 2 is ordered in February a total of 80.Products with product_id &#x3D; 3 is ordered in February a total of (2 + 3) &#x3D; 5.Products with product_id &#x3D; 4 was not ordered in February 2020.Products with product_id &#x3D; 5 is ordered in February a total of (50 + 50) &#x3D; 100.123456SELECT A.product_name,B.unit_num AS unitFROM Products AINNER JOIN (SELECT product_id, sum(unit) as unit_numFROM OrdersWHERE order_date between '2020-02-01' and '2020-02-29'HAVING sum(unit) &gt;=100) AS B1350. Students With Invalid Departments 亚麻SQL SchemaTable: Departments12345678+---------------+---------+| Column Name | Type |+---------------+---------+| id | int || name | varchar |+---------------+---------+id is the primary key of this table.The table has information about the id of each department of a university.Table: Students123456789+---------------+---------+| Column Name | Type |+---------------+---------+| id | int || name | varchar || department_id | int |+---------------+---------+id is the primary key of this table.The table has information about the id of each student at a university and the id of the department he&#x2F;she studies at.Write an SQL query to find the id and the name of all students who are enrolled in departments that no longer exists.Return the result table in any order.The query result format is in the following example:Departments table:1234567891011121314151617181920212223242526272829303132333435+------+--------------------------+| id | name |+------+--------------------------+| 1 | Electrical Engineering || 7 | Computer Engineering || 13 | Bussiness Administration |+------+--------------------------+Students table:+------+----------+---------------+| id | name | department_id |+------+----------+---------------+| 23 | Alice | 1 || 1 | Bob | 7 || 5 | Jennifer | 13 || 2 | John | 14 || 4 | Jasmine | 77 || 3 | Steve | 74 || 6 | Luis | 1 || 8 | Jonathan | 7 || 7 | Daiana | 33 || 11 | Madelynn | 1 |+------+----------+---------------+Result table:+------+----------+| id | name |+------+----------+| 2 | John || 7 | Daiana || 4 | Jasmine || 3 | Steve |+------+----------+John, Daiana, Steve and Jasmine are enrolled in departments 14, 33, 74 and 77 respectively. department 14, 33, 74 and 77 doesn&#39;t exist in the Departments table.12345SELECT s.id, s.nameFROM Departments dLEFT JOIN Students sON d.id=s.department_idWHERE s.department_id is null;1378. Replace Employee ID With The Unique IdentifierSQL SchemaTable: Employees12345678+---------------+---------+| Column Name | Type |+---------------+---------+| id | int || name | varchar |+---------------+---------+id is the primary key for this table.Each row of this table contains the id and the name of an employee in a company.Table: EmployeeUNI12345678+---------------+---------+| Column Name | Type |+---------------+---------+| id | int || unique_id | int |+---------------+---------+(id, unique_id) is the primary key for this table.Each row of this table contains the id and the corresponding unique id of an employee in the company.Write an SQL query to show the unique ID of each user, If a user doesn’t have a unique ID replace just show null.Return the result table in any order.The query result format is in the following example:Employees table:12345678910111213141516171819202122232425262728293031323334+----+----------+| id | name |+----+----------+| 1 | Alice || 7 | Bob || 11 | Meir || 90 | Winston || 3 | Jonathan |+----+----------+EmployeeUNI table:+----+-----------+| id | unique_id |+----+-----------+| 3 | 1 || 11 | 2 || 90 | 3 |+----+-----------+EmployeeUNI table:+-----------+----------+| unique_id | name |+-----------+----------+| null | Alice || null | Bob || 2 | Meir || 3 | Winston || 1 | Jonathan |+-----------+----------+Alice and Bob don&#39;t have a unique ID, We will show null instead.The unique ID of Meir is 2.The unique ID of Winston is 3.The unique ID of Jonathan is 1.1234SELECT u.unique_id, e.nameFROM Employees eLEFT JOIN EMployeeUNI uON e.id=u.id1407. Top TravellersSQL SchemaTable: Users12345678+---------------+---------+| Column Name | Type |+---------------+---------+| id | int || name | varchar |+---------------+---------+id is the primary key for this table.name is the name of the user.Table: Rides123456789+---------------+---------+| Column Name | Type |+---------------+---------+| id | int || user_id | int || distance | int |+---------------+---------+id is the primary key for this table.city_id is the id of the city who bought the product &quot;product_name&quot;.Write an SQL query to report the distance travelled by each user.Return the result table ordered by travelled_distance in descending order, if two or more users travelled the same distance, order them by their name in ascending order.The query result format is in the following example.Users table:123456789101112131415161718192021222324252627282930313233343536373839404142+------+-----------+| id | name |+------+-----------+| 1 | Alice || 2 | Bob || 3 | Alex || 4 | Donald || 7 | Lee || 13 | Jonathan || 19 | Elvis |+------+-----------+Rides table:+------+----------+----------+| id | user_id | distance |+------+----------+----------+| 1 | 1 | 120 || 2 | 2 | 317 || 3 | 3 | 222 || 4 | 7 | 100 || 5 | 13 | 312 || 6 | 19 | 50 || 7 | 7 | 120 || 8 | 19 | 400 || 9 | 7 | 230 |+------+----------+----------+Result table:+----------+--------------------+| name | travelled_distance |+----------+--------------------+| Elvis | 450 || Lee | 450 || Bob | 317 || Jonathan | 312 || Alex | 222 || Alice | 120 || Donald | 0 |+----------+--------------------+Elvis and Lee travelled 450 miles, Elvis is the top traveller as his name is alphabetically smaller than Lee.Bob, Jonathan, Alex and Alice have only one ride and we just order them by the total distances of the ride.Donald didn&#39;t have any rides, the distance travelled by him is 0.考点是IFNULL，如果不写，Donald会是NULL123456SELECT u.name, IFNULL(sum(r.distance),0) as travelled_distanceFROM Users uLEFT JOIN Rides rON u.id = r.idGROUP BY u.nameORDER BY travelled_distance DESC, u.name;","categories":[{"name":"Database","slug":"Database","permalink":"http://yoursite.com/categories/Database/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/tags/Leetcode/"}]}],"categories":[{"name":"Database","slug":"Database","permalink":"http://yoursite.com/categories/Database/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/tags/Leetcode/"},{"name":"Facebook","slug":"Facebook","permalink":"http://yoursite.com/tags/Facebook/"}]}